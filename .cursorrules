You are an expert developer in TypeScript, Node.js, React, Supabase, Tailwind CSS, and Electron.

Key Principles
- Write concise, technical responses with accurate TypeScript examples.
- Use functional, declarative programming. Avoid classes.
- Prefer iteration and modularization over duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.
- Use the Receive an Object, Return an Object (RORO) pattern.

JavaScript/TypeScript
- Use "function" keyword for pure functions. Omit semicolons.
- Use TypeScript for all code. Prefer interfaces over types.
- File structure: Exported component, subcomponents, helpers, static content, types.
- Avoid unnecessary curly braces in conditional statements.
- For single-line statements in conditionals, omit curly braces.
- Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething()).

Error Handling and Validation
- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Consider using custom error types or error factories for consistent error handling.
  - Always validate data from Supabase before processing.
  - **CRITICAL: Parallel Data Loading Resilience**:
    - When loading multiple data sources in parallel (e.g., Promise.all), ensure that if one source fails, the others continue to load successfully.
    - Use Promise.allSettled() or individual try-catch blocks for independent data sources that may fail.
    - Never use Promise.all() for data sources that can fail independently - this causes all requests to fail if one fails.
    - Create helper functions (e.g., safeLoad) that wrap individual data loading calls with error handling, returning empty arrays or default values on failure.
    - Log errors for failed data sources but continue processing successful ones.
    - Example pattern: Separate problematic tables (with known issues like RLS recursion) into Promise.allSettled(), while critical tables load in Promise.all() with individual error handling.

React/TypeScript
- Use functional components and TypeScript interfaces.
- Use declarative JSX.
- Use function, not const, for components.
- Use Tailwind CSS for components and styling.
- Implement responsive design with Tailwind CSS.
- Use mobile-first approach for responsive design.
- Place static content and interfaces at file end.
- Use content variables for static content outside render functions.
- Minimize 'useEffect' and 'setState'. Favor React hooks and context.
- Use custom hooks for complex state logic.
- Wrap components in error boundaries for unexpected errors.
- Implement type-safe form validation with proper error handling.
- Handle errors gracefully and return appropriate responses.

Supabase Integration
- Use the Supabase client for database interactions and real-time subscriptions.
- Implement Row Level Security (RLS) policies for fine-grained access control.
- Use Supabase Auth for user authentication and management.
- Leverage Supabase Storage for file uploads and management when needed.
- Use the 'sense' schema for all database queries (e.g., sense.pais, sense.empresa).
- Optimize queries to fetch only necessary data.
- Implement proper authentication and authorization using Supabase RLS and Policies.
- Always handle Supabase errors gracefully with user-friendly messages.
- Use proper TypeScript types for Supabase responses.

JoySense Project Specific
- Follow the established project structure:
  - Frontend: React with TypeScript in frontend/src/
  - Backend: Node.js with Express in backend/
  - Database: Supabase with 'sense' schema
  - Deployment: Scripts in deployment/ directory
- Use the established component patterns:
  - SystemParameters for parameter management
  - Dashboard components for data visualization
  - Sidebar components for navigation
  - Form components with proper validation
- Maintain consistency with existing UI patterns and styling.
- Use the established error handling patterns in utils/errorHandler.ts.
- Follow the existing authentication flow with AuthContext.

Key Conventions
1. Rely on React Router for navigation and state changes.
2. Prioritize performance and user experience.
3. Minimize client-side state management:
  - Prefer server-side data fetching when possible.
  - Use React Context for global state.
  - Avoid unnecessary re-renders.
4. Follow the established project structure:
  - Keep frontend code in frontend/src/
  - Keep backend code in backend/
  - Keep deployment scripts in deployment/
  - Keep documentation in docs/
  - Keep SQL scripts in sql/
5. Use the established database schema and naming conventions.
6. Adhere to the defined table relationships and constraints.

Naming Conventions
- Booleans: Use auxiliary verbs such as 'does', 'has', 'is', and 'should' (e.g., isDisabled, hasError).
- Filenames: Use PascalCase for components (e.g., SystemParameters.tsx).
- File extensions: Use .tsx for React components, .ts for utilities, .css for styles.
- Database: Use lowercase with underscores (e.g., user_created_id, date_created).

Component Structure
- Break down components into smaller parts with minimal props.
- Use composition to build complex components.
- Follow the order: imports, interfaces, component declaration, helpers, exports.
- Keep components focused on single responsibilities.

Data Fetching and State Management
- Use React hooks for data fetching and state management.
- Implement proper loading states and error handling.
- Use Supabase for real-time data synchronization.
- Cache frequently accessed data appropriately.
- Use the established service patterns in services/ directory.
- **Parallel Data Loading**: When loading multiple related tables (e.g., in loadRelatedTablesData):
  - Separate tables with known issues (RLS recursion, errors) using Promise.allSettled() to prevent cascading failures.
  - Use individual error handling (safeLoad pattern) for each data source to ensure resilience.
  - Critical data sources (like tipos for sensor forms) should always load even if other tables fail.
  - Never let one failing table prevent other tables from loading successfully.

Styling
- Use Tailwind CSS for styling, following the Utility First approach.
- Maintain consistency with the established design system.
- Use the established color scheme and spacing patterns.
- Implement responsive design for all components.

Testing
- Implement unit tests for utility functions and hooks.
- Use integration tests for complex components.
- Test Supabase interactions with proper mocking.
- Ensure all critical user flows are tested.

Accessibility
- Ensure interfaces are keyboard navigable.
- Implement proper ARIA labels and roles for components.
- Ensure color contrast ratios meet WCAG standards.
- Test with screen readers when possible.

Documentation
- Provide clear and concise comments for complex logic.
- Use JSDoc comments for functions and components.
- Keep the README files up-to-date with setup instructions.
- Document Supabase schema, RLS policies, and API endpoints.
- Maintain the project documentation in docs/ directory.

Project-Specific Guidelines
- Always use the 'joysense' schema for database queries.
- Follow the established error handling patterns.
- Use the existing authentication and authorization system.
- Maintain consistency with the established UI/UX patterns.
- Follow the established deployment and build processes.
- Use the established logging and debugging patterns.

System Commands and Git Operations
- **CRITICAL: Use appropriate commands for each OS**:
  - **Windows/PowerShell**: Use `Move-Item` instead of `mv`, `Remove-Item` instead of `rm`, `Copy-Item` instead of `cp`
  - **Unix/Linux**: Use `mv`, `rm`, `cp` as usual
  - **Never mix commands** between different OS environments

- **PowerShell Specific Limitations**:
  - **NEVER use `&&`**: PowerShell does NOT support `&&` operator for chaining commands
    - ‚ùå WRONG: `git add -A && git status`
    - ‚úÖ CORRECT: Use `;` or separate Shell calls: `git add -A ; git status` OR make two separate Shell tool calls
  - **NEVER use HEREDOC (`<<'EOF'`)**: PowerShell does NOT support bash-style heredocs
    - ‚ùå WRONG: `git commit -m "$(cat <<'EOF' ... EOF)"`
    - ‚úÖ CORRECT: Use simple quoted strings: `git commit -m "Message line 1`n`nMessage line 2"`
  - **For multi-line strings in PowerShell**:
    - Use backtick-n for newlines: `` `n ``
    - Or use simple double quotes with actual line breaks
  - **Command separation**:
    - Use `;` (semicolon) to chain commands that should run sequentially
    - Use separate Shell tool calls for better error handling
    - Prefer separate calls over chaining when possible

- **Git Operations Best Practices**:
  - **Always check git status** before operations: `git status`
  - **For ignored files**: Use `git add -f <file>` to force add ignored files
  - **For moving files**: Use `git mv <source> <destination>` to track renames properly
  - **For deletions**: Use `git rm <file>` for tracked files, `git rm --cached <file>` to untrack without deleting
  - **Commit messages in PowerShell**: 
    - Simple message: `git commit -m "Single line message"`
    - Multi-line: `git commit -m "Title`n`nBody paragraph 1`n`nBody paragraph 2"`
    - Complex multi-line: Make separate Shell calls (commit -m with simple message)
  - **Large file operations**: Break into smaller commits when possible

- **File Operations in Windows Environment**:
  - **Moving files**: `Move-Item source destination` (not `mv`)
  - **Copying files**: `Copy-Item source destination` (not `cp`)
  - **Removing files**: `Remove-Item file` (not `rm`)
  - **Creating directories**: `New-Item -ItemType Directory -Path path` (not `mkdir`)
  - **Path separators**: Use forward slashes `/` in paths, PowerShell handles conversion automatically

- **Error Prevention**:
  - **Check file existence** before operations: `Test-Path file`
  - **Use absolute paths** when working with ignored files
  - **Verify commands** work in target environment before assuming they work everywhere
  - **Use quotes** around paths with spaces: `"path with spaces"`
  - **Check PowerShell execution policy** if commands fail unexpectedly

- **Common Command Translations**:
  - Unix `mv file1 file2` ‚Üí PowerShell `Move-Item file1 file2`
  - Unix `cp file1 file2` ‚Üí PowerShell `Copy-Item file1 file2`
  - Unix `rm file` ‚Üí PowerShell `Remove-Item file`
  - Unix `mkdir dir` ‚Üí PowerShell `New-Item -ItemType Directory -Path dir`
  - Unix `ls` ‚Üí PowerShell `Get-ChildItem` or `dir`
  - Unix `cat file` ‚Üí PowerShell `Get-Content file`

- **Git Commands in Different Contexts**:
  - **Adding ignored files**: `git add -f schema/funciones_permisos/`
  - **Committing ignored files**: Works normally after `git add -f`
  - **Status of ignored files**: Shows as untracked until added with `-f`
  - **Moving ignored files**: `Move-Item` then `git add -f` in new location

- **Debugging Command Issues**:
  - **Check current directory**: `pwd` or `Get-Location`
  - **List files**: `Get-ChildItem` or `ls` or `dir`
  - **Check if path exists**: `Test-Path path`
  - **Check command availability**: `Get-Command command-name`
  - **Check PowerShell version**: `$PSVersionTable.PSVersion`

- **Best Practices for File Operations**:
  - **Test commands** in PowerShell console before using in scripts
  - **Use absolute paths** for critical operations
  - **Verify operations** with `Get-ChildItem` after file operations
  - **Check git status** frequently during complex operations
  - **Use descriptive commit messages** that explain the purpose and scope


# .cursorrules

- match: "*"
  rules:
    # üîπ Regla 1: limitar tama√±o de respuesta
    - "Responde √∫nicamente con lo m√≠nimo necesario, sin explicaciones largas ni detalles innecesarios."

    # üîπ Regla 2: control de creaci√≥n de archivos
    - "Solo crear archivos si el usuario lo solicita expl√≠citamente."
    - "Los formatos permitidos son √∫nicamente `.md` o `.txt`."
    - "No crear archivos en otros formatos bajo ninguna circunstancia."