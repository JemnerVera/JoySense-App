CREATE SCHEMA IF NOT EXISTS joysense;

CREATE  TABLE joysense.alertaconsolidado ( 
	uuid_consolidadoid   uuid DEFAULT gen_random_uuid() NOT NULL  ,
	umbralid             bigint  NOT NULL  ,
	fechainicio          timestamptz DEFAULT now() NOT NULL  ,
	fechaultimo          timestamptz DEFAULT now() NOT NULL  ,
	fechaultimacorrida   timestamptz    ,
	ultimamedicion       decimal  NOT NULL  ,
	contador             integer DEFAULT 1 NOT NULL  ,
	nivelnotificado      integer    ,
	ultimoenvio          timestamptz    ,
	ultimoescalamiento   timestamptz    ,
	nivelescalamiento    integer    ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT alerta_consolidado_pkey PRIMARY KEY ( uuid_consolidadoid )
 );

CREATE  TABLE joysense.codigotelefono ( 
	codigotelefonoid     integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	codigotelefono       varchar(8)  NOT NULL  ,
	paistelefono         varchar(50)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_codigotelefono_0 PRIMARY KEY ( codigotelefonoid ),
	CONSTRAINT unq_codigotelefono_0 UNIQUE ( codigotelefono, paistelefono ) 
 );

ALTER TABLE joysense.codigotelefono ADD CONSTRAINT cns_contacto_0 CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.criticidad ( 
	criticidadid         integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	criticidad           varchar(20)  NOT NULL  ,
	grado                integer  NOT NULL  ,
	frecuencia           integer DEFAULT 1 NOT NULL  ,
	escalamiento         integer DEFAULT 2 NOT NULL  ,
	escalon              integer  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_origin_0 PRIMARY KEY ( criticidadid ),
	CONSTRAINT unq_criticidad UNIQUE ( criticidad ) 
 );

ALTER TABLE joysense.criticidad ADD CONSTRAINT cns_criticidad CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.entidad ( 
	entidadid            integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	entidad              varchar(50)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_entidad PRIMARY KEY ( entidadid )
 );

ALTER TABLE joysense.entidad ADD CONSTRAINT cns_entidad_0 CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.metrica ( 
	metricaid            integer  NOT NULL GENERATED  BY DEFAULT AS IDENTITY ,
	metrica              varchar(50)  NOT NULL  ,
	unidad               varchar(10)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT metrica_pkey PRIMARY KEY ( metricaid ),
	CONSTRAINT unq_metrica UNIQUE ( metrica ) 
 );

ALTER TABLE joysense.metrica ADD CONSTRAINT cns_metrica CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.pais ( 
	paisid               integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	pais                 varchar(50)  NOT NULL  ,
	paisabrev            varchar(2)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL  ,
	CONSTRAINT pk_pais PRIMARY KEY ( paisid ),
	CONSTRAINT unq_pais_0 UNIQUE ( paisabrev ) ,
	CONSTRAINT unq_pais UNIQUE ( pais ) 
 );

ALTER TABLE joysense.pais ADD CONSTRAINT cns_pais CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.perfil ( 
	perfilid             integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	perfil               varchar(50)  NOT NULL  ,
	nivel                integer DEFAULT 0 NOT NULL  ,
	jefeid               integer    ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_nivel PRIMARY KEY ( perfilid ),
	CONSTRAINT perfil_perfil_key UNIQUE ( perfil ) 
 );

ALTER TABLE joysense.perfil ADD CONSTRAINT cns_perfil CHECK ( statusid = ANY (ARRAY[0, 1]) );

ALTER TABLE joysense.perfil ADD CONSTRAINT chk_nivel_hierarchy CHECK ( (jefeid IS NULL) OR (nivel > 0) );

CREATE INDEX idx_perfil_jefeid ON joysense.perfil  ( jefeid );

CREATE  TABLE joysense.perfil_geografia_permiso ( 
	permisoid            bigint  NOT NULL GENERATED  BY DEFAULT AS IDENTITY ,
	perfilid             integer  NOT NULL  ,
	paisid               integer    ,
	empresaid            integer    ,
	fundoid              integer    ,
	ubicacionid          integer    ,
	puede_ver            boolean DEFAULT false NOT NULL  ,
	puede_insertar       boolean DEFAULT false NOT NULL  ,
	puede_actualizar     boolean DEFAULT false NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT perfil_geografia_permiso_pkey PRIMARY KEY ( permisoid )
 );

ALTER TABLE joysense.perfil_geografia_permiso ADD CONSTRAINT chk_permiso_geografia_nivel CHECK ( (((((paisid IS NOT NULL))::integer + ((empresaid IS NOT NULL))::integer) + ((fundoid IS NOT NULL))::integer) + ((ubicacionid IS NOT NULL))::integer) = 1 );

CREATE  TABLE joysense.sensor_valor ( 
	id_device            varchar(50)  NOT NULL  ,
	fecha                timestamptz  NOT NULL  ,
	valor                double precision  NOT NULL  ,
	statusid             integer  NOT NULL  ,
	CONSTRAINT sensor_valor_pkey PRIMARY KEY ( id_device, fecha )
 );

ALTER TABLE joysense.sensor_valor ADD CONSTRAINT chk_sensor_valor_statusid CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.sensor_valor_error ( 
	sensorvalorerrorid   bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	id_device            varchar(50)  NOT NULL  ,
	error                varchar(200)  NOT NULL  ,
	valor                double precision  NOT NULL  ,
	fecha                timestamptz  NOT NULL  ,
	statusid             integer DEFAULT '-1'::integer NOT NULL  ,
	CONSTRAINT pk_sensor_valor_error PRIMARY KEY ( sensorvalorerrorid )
 );

ALTER TABLE joysense.sensor_valor_error ADD CONSTRAINT chk_sensor_valor_error_statusid CHECK ( statusid = ANY (ARRAY['-1'::integer, 0, 1]) );

CREATE  TABLE joysense.tipo ( 
	tipoid               integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	tipo                 varchar(50)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_tipo PRIMARY KEY ( tipoid ),
	CONSTRAINT unq_tipo_tipo UNIQUE ( tipo ) 
 );

ALTER TABLE joysense.tipo ADD CONSTRAINT cns_tipo CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.usuario ( 
	usuarioid            integer  NOT NULL GENERATED  BY DEFAULT AS IDENTITY ,
	usuariouuid          uuid    ,
	login                varchar(50)  NOT NULL  ,
	lastname             varchar(50)  NOT NULL  ,
	firstname            varchar(50)  NOT NULL  ,
	password_hash        text  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	useruuid             uuid    ,
	CONSTRAINT usuario_pkey PRIMARY KEY ( usuarioid ),
	CONSTRAINT unq_usuario UNIQUE ( login ) 
 );

ALTER TABLE joysense.usuario ADD CONSTRAINT cns_usuario CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.usuarioperfil ( 
	usuarioid            integer  NOT NULL  ,
	perfilid             integer  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT usuarioperfil_pkey PRIMARY KEY ( usuarioid, perfilid )
 );

ALTER TABLE joysense.usuarioperfil ADD CONSTRAINT cns_usuarioperfil CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE INDEX idx_usuarioperfil_usuario_act ON joysense.usuarioperfil  ( usuarioid, perfilid ) WHERE (statusid = 1);

CREATE INDEX idx_usuarioperfil_perfil_act ON joysense.usuarioperfil  ( perfilid ) WHERE (statusid = 1);

CREATE INDEX idx_usuarioperfil_pf_stat ON joysense.usuarioperfil  ( perfilid, statusid );

CREATE  TABLE joysense.contacto ( 
	contactoid           integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	usuarioid            integer  NOT NULL  ,
	codigotelefonoid     integer  NOT NULL  ,
	celular              varchar(12)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_contacto PRIMARY KEY ( contactoid )
 );

ALTER TABLE joysense.contacto ADD CONSTRAINT cns_contacto CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE INDEX idx_contacto_usr_stat ON joysense.contacto  ( usuarioid, statusid );

CREATE  TABLE joysense.correo ( 
	correoid             integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	usuarioid            integer  NOT NULL  ,
	correo               varchar(50)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_correo PRIMARY KEY ( correoid )
 );

ALTER TABLE joysense.correo ADD CONSTRAINT cns_medio CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.empresa ( 
	empresaid            integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	paisid               integer  NOT NULL  ,
	empresa              varchar(50)  NOT NULL  ,
	empresabrev          varchar(10)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_empresa PRIMARY KEY ( empresaid ),
	CONSTRAINT unq_empresa UNIQUE ( paisid, empresa ) ,
	CONSTRAINT unq_empresa_0 UNIQUE ( paisid, empresabrev ) 
 );

ALTER TABLE joysense.empresa ADD CONSTRAINT cns_empresa CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.fundo ( 
	fundoid              integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	empresaid            integer  NOT NULL  ,
	fundo                varchar(50)  NOT NULL  ,
	fundoabrev           varchar(10)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_fundo PRIMARY KEY ( fundoid ),
	CONSTRAINT unq_fundo UNIQUE ( empresaid, fundo ) ,
	CONSTRAINT unq_fundo_0 UNIQUE ( empresaid, fundoabrev ) 
 );

ALTER TABLE joysense.fundo ADD CONSTRAINT cns_fundo CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.mensaje ( 
	uuid_origen          uuid  NOT NULL  ,
	contactoid           integer  NOT NULL  ,
	tipo_origen          varchar(20)  NOT NULL  ,
	mensaje              varchar(1000)  NOT NULL  ,
	fecha                timestamptz DEFAULT now() NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_mensaje PRIMARY KEY ( uuid_origen, contactoid )
 );

ALTER TABLE joysense.mensaje ADD CONSTRAINT chk_mensaje_statusid CHECK ( statusid = ANY (ARRAY['-1'::integer, 0, 1]) );

CREATE  TABLE joysense.sensor ( 
	sensorid             integer  NOT NULL  ,
	tipoid               integer  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_sensor PRIMARY KEY ( sensorid )
 );

ALTER TABLE joysense.sensor ADD CONSTRAINT cns_sensor CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.ubicacion ( 
	ubicacionid          integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	fundoid              integer  NOT NULL  ,
	ubicacion            varchar(50)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT ubicacion_pkey PRIMARY KEY ( ubicacionid ),
	CONSTRAINT unq_ubicacion UNIQUE ( fundoid, ubicacion ) 
 );

ALTER TABLE joysense.ubicacion ADD CONSTRAINT cns_ubicacion CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.metricasensor ( 
	sensorid             integer  NOT NULL  ,
	metricaid            integer  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_metricasensor PRIMARY KEY ( sensorid, metricaid )
 );

ALTER TABLE joysense.metricasensor ADD CONSTRAINT cns_metricasensor CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.nodo ( 
	nodoid               bigint  NOT NULL GENERATED  BY DEFAULT AS IDENTITY ,
	ubicacionid          integer  NOT NULL  ,
	nodo                 varchar(100)  NOT NULL  ,
	descripcion          varchar(100)    ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT nodo_pkey PRIMARY KEY ( nodoid ),
	CONSTRAINT unq_nodo UNIQUE ( ubicacionid, nodo ) 
 );

ALTER TABLE joysense.nodo ADD CONSTRAINT cns_nodo CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.localizacion ( 
	localizacionid       integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	nodoid               bigint  NOT NULL  ,
	sensorid             integer  NOT NULL  ,
	metricaid            integer  NOT NULL  ,
	localizacion         varchar(50)  NOT NULL  ,
	latitud              decimal(10,6)    ,
	longitud             decimal(10,6)    ,
	referencia           varchar(100)    ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_localizacion PRIMARY KEY ( localizacionid )
 );

ALTER TABLE joysense.localizacion ADD CONSTRAINT cns_localizacion CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE INDEX idx_localizacion_nodoid ON joysense.localizacion  ( nodoid );

CREATE  TABLE joysense.medicion ( 
	medicionid           bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	localizacionid       integer  NOT NULL  ,
	fecha                timestamptz  NOT NULL  ,
	medicion             double precision  NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_medicion PRIMARY KEY ( medicionid )
 );

CREATE INDEX idx_medicion_fecha ON joysense.medicion  ( fecha  DESC   );

CREATE INDEX idx_medicion_ubicacion_nodo_fecha ON joysense.medicion  ( localizacionid, fecha );

CREATE  TABLE joysense.umbral ( 
	umbralid             bigint  NOT NULL GENERATED  BY DEFAULT AS IDENTITY ,
	localizacionid       integer  NOT NULL  ,
	criticidadid         integer  NOT NULL  ,
	umbral               varchar(50)  NOT NULL  ,
	maximo               double precision  NOT NULL  ,
	minimo               double precision  NOT NULL  ,
	estandar             double precision    ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_umbral PRIMARY KEY ( umbralid )
 );

ALTER TABLE joysense.umbral ADD CONSTRAINT cns_umbral CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE INDEX idx_umbral_lookup_robusto ON joysense.umbral  ( localizacionid, statusid ) WHERE ((statusid = 1) AND (minimo IS NOT NULL) AND (maximo IS NOT NULL));

CREATE  TABLE joysense.alerta ( 
	uuid_alertaid        uuid DEFAULT gen_random_uuid() NOT NULL  ,
	medicionid           bigint  NOT NULL  ,
	umbralid             bigint  NOT NULL  ,
	fecha                timestamptz DEFAULT now() NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT alerta_pkey PRIMARY KEY ( uuid_alertaid )
 );

ALTER TABLE joysense.alerta ADD CONSTRAINT chk_alerta_statusid CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE INDEX idx_alerta ON joysense.alerta  ( umbralid  DESC   );

CREATE  TABLE joysense.asociacion ( 
	asociacionid         bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	localizacionid       integer  NOT NULL  ,
	id_device            varchar(50)  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_asociacion PRIMARY KEY ( asociacionid )
 );

ALTER TABLE joysense.asociacion ADD CONSTRAINT cns_entidad_1 CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE UNIQUE INDEX unq_asociacion ON joysense.asociacion ( localizacionid ) WHERE (statusid = 1);

CREATE  TABLE joysense.audit_log_umbral ( 
	auditid              bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	umbralid             bigint  NOT NULL  ,
	old_minimo           double precision    ,
	new_minimo           double precision    ,
	old_maximo           double precision    ,
	new_maximo           double precision    ,
	old_criticidadid     integer    ,
	new_criticidadid     integer    ,
	accion               varchar(10)  NOT NULL  ,
	modified_by          integer  NOT NULL  ,
	modified_at          timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT audit_log_umbral_pkey PRIMARY KEY ( auditid )
 );

ALTER TABLE joysense.audit_log_umbral ADD CONSTRAINT audit_log_umbral_accion_check CHECK ( accion)::text = ANY ((ARRAY['INSERT'::character varying, 'UPDATE'::character varying, 'DELETE'::character varying])::text[] );

CREATE  TABLE joysense.entidad_localizacion ( 
	entidadid            integer  NOT NULL  ,
	localizacionid       integer  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_entidad_localizacion PRIMARY KEY ( entidadid, localizacionid )
 );

ALTER TABLE joysense.entidad_localizacion ADD CONSTRAINT cns_entidad_2 CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE  TABLE joysense.perfilumbral ( 
	perfilid             integer  NOT NULL  ,
	umbralid             bigint  NOT NULL  ,
	statusid             integer DEFAULT 1 NOT NULL  ,
	usercreatedid        integer  NOT NULL  ,
	datecreated          timestamptz DEFAULT now() NOT NULL  ,
	usermodifiedid       integer  NOT NULL  ,
	datemodified         timestamptz DEFAULT now() NOT NULL  ,
	CONSTRAINT pk_perfilumbral PRIMARY KEY ( perfilid, umbralid )
 );

ALTER TABLE joysense.perfilumbral ADD CONSTRAINT cns_perfilumbral CHECK ( statusid = ANY (ARRAY[0, 1]) );

CREATE INDEX idx_perfilumbral_umbral_act ON joysense.perfilumbral  ( umbralid, perfilid ) WHERE (statusid = 1);

CREATE INDEX idx_perfilumbral_perfil_act ON joysense.perfilumbral  ( perfilid ) WHERE (statusid = 1);

CREATE INDEX idx_perfilumbral_lookup_robusto ON joysense.perfilumbral  ( umbralid, perfilid, statusid ) WHERE (statusid = 1);

ALTER TABLE joysense.alerta ADD CONSTRAINT fk_alerta_medicion FOREIGN KEY ( medicionid ) REFERENCES joysense.medicion( medicionid );

ALTER TABLE joysense.alerta ADD CONSTRAINT fk_alerta_umbral FOREIGN KEY ( umbralid ) REFERENCES joysense.umbral( umbralid );

ALTER TABLE joysense.asociacion ADD CONSTRAINT fk_asociacion_localizacion FOREIGN KEY ( localizacionid ) REFERENCES joysense.localizacion( localizacionid );

ALTER TABLE joysense.audit_log_umbral ADD CONSTRAINT fk_audit_log_umbral_umbral FOREIGN KEY ( umbralid ) REFERENCES joysense.umbral( umbralid );

ALTER TABLE joysense.contacto ADD CONSTRAINT fk_contacto_usuario FOREIGN KEY ( usuarioid ) REFERENCES joysense.usuario( usuarioid );

ALTER TABLE joysense.contacto ADD CONSTRAINT fk_contacto_codigotelefono FOREIGN KEY ( codigotelefonoid ) REFERENCES joysense.codigotelefono( codigotelefonoid );

ALTER TABLE joysense.correo ADD CONSTRAINT fk_correo_usuario FOREIGN KEY ( usuarioid ) REFERENCES joysense.usuario( usuarioid );

ALTER TABLE joysense.empresa ADD CONSTRAINT fk_empresa_pais FOREIGN KEY ( paisid ) REFERENCES joysense.pais( paisid );

ALTER TABLE joysense.entidad_localizacion ADD CONSTRAINT fk_entidad_localizacion_localizacion FOREIGN KEY ( localizacionid ) REFERENCES joysense.localizacion( localizacionid );

ALTER TABLE joysense.entidad_localizacion ADD CONSTRAINT fk_entidad_localizacion_entidad FOREIGN KEY ( entidadid ) REFERENCES joysense.entidad( entidadid );

ALTER TABLE joysense.fundo ADD CONSTRAINT fk_fundo_empresa FOREIGN KEY ( empresaid ) REFERENCES joysense.empresa( empresaid );

ALTER TABLE joysense.localizacion ADD CONSTRAINT fk_localizacion_nodo FOREIGN KEY ( nodoid ) REFERENCES joysense.nodo( nodoid );

ALTER TABLE joysense.localizacion ADD CONSTRAINT fk_localizacion_metricasensor FOREIGN KEY ( sensorid, metricaid ) REFERENCES joysense.metricasensor( sensorid, metricaid );

ALTER TABLE joysense.medicion ADD CONSTRAINT fk_medicion_localizacion FOREIGN KEY ( localizacionid ) REFERENCES joysense.localizacion( localizacionid );

ALTER TABLE joysense.mensaje ADD CONSTRAINT fk_mensaje_contacto FOREIGN KEY ( contactoid ) REFERENCES joysense.contacto( contactoid );

ALTER TABLE joysense.metricasensor ADD CONSTRAINT fk_metricadispositivo_metrica FOREIGN KEY ( metricaid ) REFERENCES joysense.metrica( metricaid );

ALTER TABLE joysense.metricasensor ADD CONSTRAINT fk_metricasensor_sensor FOREIGN KEY ( sensorid ) REFERENCES joysense.sensor( sensorid );

ALTER TABLE joysense.nodo ADD CONSTRAINT fk_nodo_ubicacion FOREIGN KEY ( ubicacionid ) REFERENCES joysense.ubicacion( ubicacionid );

ALTER TABLE joysense.perfil ADD CONSTRAINT fk_perfil_jefe FOREIGN KEY ( jefeid ) REFERENCES joysense.perfil( perfilid );

ALTER TABLE joysense.perfil_geografia_permiso ADD CONSTRAINT perfil_geografia_permiso_perfilid_fkey FOREIGN KEY ( perfilid ) REFERENCES joysense.perfil( perfilid );

ALTER TABLE joysense.perfilumbral ADD CONSTRAINT fk_perfilumbral_perfil FOREIGN KEY ( perfilid ) REFERENCES joysense.perfil( perfilid );

ALTER TABLE joysense.perfilumbral ADD CONSTRAINT fk_perfilumbral_umbral FOREIGN KEY ( umbralid ) REFERENCES joysense.umbral( umbralid );

ALTER TABLE joysense.sensor ADD CONSTRAINT fk_sensor_tipo FOREIGN KEY ( tipoid ) REFERENCES joysense.tipo( tipoid );

ALTER TABLE joysense.ubicacion ADD CONSTRAINT fk_ubicacion_fundo FOREIGN KEY ( fundoid ) REFERENCES joysense.fundo( fundoid );

ALTER TABLE joysense.umbral ADD CONSTRAINT fk_umbral_criticidad FOREIGN KEY ( criticidadid ) REFERENCES joysense.criticidad( criticidadid );

ALTER TABLE joysense.umbral ADD CONSTRAINT fk_umbral_localizacion FOREIGN KEY ( localizacionid ) REFERENCES joysense.localizacion( localizacionid );

ALTER TABLE joysense.usuarioperfil ADD CONSTRAINT fk_usuarioperfil_usuario FOREIGN KEY ( usuarioid ) REFERENCES joysense.usuario( usuarioid );

ALTER TABLE joysense.usuarioperfil ADD CONSTRAINT fk_usuarioperfil_perfil FOREIGN KEY ( perfilid ) REFERENCES joysense.perfil( perfilid );

CREATE OR REPLACE FUNCTION joysense.fn_auditar_umbral()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth'
AS $function$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO joysense.audit_log_umbral(
        umbralid,
        new_minimo,
        new_maximo,
        new_criticidadid,
        modified_by,
        accion
    )
    VALUES (
        NEW.umbralid,
        NEW.minimo,
        NEW.maximo,
        NEW.criticidadid,
        NEW.usermodifiedid,
        'INSERT'
    );
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO joysense.audit_log_umbral(
        umbralid,
        old_minimo,
        new_minimo,
        old_maximo,
        new_maximo,
        old_criticidadid,
        new_criticidadid,
        modified_by,
        accion
    )
    VALUES (
        NEW.umbralid,
        OLD.minimo,
        NEW.minimo,
        OLD.maximo,
        NEW.maximo,
        OLD.criticidadid,
        NEW.criticidadid,
        NEW.usermodifiedid,
        'UPDATE'
    );
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_consolidar_alertas()
 RETURNS TABLE(log_msg text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth'
AS $function$
DECLARE
  v_now          timestamptz := now();
  v_hour_end     timestamptz := v_now;
  v_hour_start   timestamptz := v_hour_end - interval '1 hour';
  v_frecuencia       integer;
  v_escalamiento     integer;
  v_ultimo           timestamptz;
  v_nivel_max        integer;
  v_nivel_base       integer;
  v_criticidad       varchar(20);
  v_nivelnotificado  integer;
  v_max_length       integer := 215;
  r RECORD;
BEGIN
  log_msg := '--- INICIO fn_consolidar_alertas ---'; RETURN NEXT;
  log_msg := format(
    'Hora actual=%s | Hora inicio=%s | Hora fin=%s',
    v_now, v_hour_start, v_hour_end
  ); RETURN NEXT;
  ----------------------------------------------------------------
  -- 1) Consolidación de la última hora
  ----------------------------------------------------------------
  log_msg := '>>> Consolidando alertas de la última hora...'; RETURN NEXT;
  WITH ultimas AS (
    SELECT
      a.umbralid,
      MIN(a.fecha) AS min_fecha,
      MAX(a.fecha) AS max_fecha,
      COUNT(*)     AS cnt
    FROM joysense.alerta a
    WHERE a.fecha >= v_hour_start
      AND a.fecha <= v_hour_end
    GROUP BY a.umbralid
  ),
  ult_med AS (
    SELECT
      x.umbralid,
      m.medicion AS ultima_medicion
    FROM (
      SELECT
        a.umbralid,
        a.medicionid,
        ROW_NUMBER() OVER (
          PARTITION BY a.umbralid
          ORDER BY m.fecha DESC
        ) AS rn
      FROM joysense.alerta a
      JOIN joysense.medicion m
        ON m.medicionid = a.medicionid
      WHERE a.fecha >= v_hour_start
        AND a.fecha <= v_hour_end
    ) x
    JOIN joysense.medicion m
      ON m.medicionid = x.medicionid
    WHERE x.rn = 1
  ),
  merged AS (
    SELECT u.umbralid, u.min_fecha, u.max_fecha, u.cnt, um.ultima_medicion
    FROM ultimas u
    JOIN ult_med um USING (umbralid)
  ),
  upserted AS (
    UPDATE joysense.alertaconsolidado ac
    SET
      fechaultimo        = GREATEST(ac.fechaultimo, m.max_fecha),
      fechaultimacorrida = v_hour_end,
      contador           = m.cnt,
      ultimamedicion     = m.ultima_medicion,
      usermodifiedid     = COALESCE(ac.usermodifiedid, 1),
      datemodified       = now()
    FROM merged m
    WHERE ac.umbralid = m.umbralid
      AND ac.statusid = 1
    RETURNING ac.uuid_consolidadoid, ac.umbralid
  ),
  inserted AS (
    INSERT INTO joysense.alertaconsolidado (
      umbralid,
      fechainicio,
      fechaultimo,
      fechaultimacorrida,
      ultimamedicion,
      contador,
      statusid,
      usercreatedid,
      datecreated,
      usermodifiedid,
      datemodified
    )
    SELECT
      m.umbralid,
      m.min_fecha,
      m.max_fecha,
      v_hour_end,
      m.ultima_medicion,
      m.cnt,
      1,
      1,
      now(),
      1,
      now()
    FROM merged m
    WHERE NOT EXISTS (
      SELECT 1
      FROM joysense.alertaconsolidado ac
      WHERE ac.umbralid = m.umbralid
        AND ac.statusid = 1
    )
    RETURNING uuid_consolidadoid, umbralid
  )
  UPDATE joysense.alertaconsolidado ac
  SET
    statusid           = 0,
    usermodifiedid     = 1,
    datemodified       = now(),
    fechaultimacorrida = v_hour_end
  WHERE ac.statusid = 1
    AND ac.fechaultimacorrida IS DISTINCT FROM v_hour_end
    AND NOT EXISTS (
      SELECT 1 FROM upserted u
      WHERE u.uuid_consolidadoid = ac.uuid_consolidadoid
    )
    AND NOT EXISTS (
      SELECT 1 FROM inserted i
      WHERE i.uuid_consolidadoid = ac.uuid_consolidadoid
    );
  log_msg := '>>> Consolidación terminada.'; RETURN NEXT;
  ----------------------------------------------------------------
  -- 2) Revisión de criticidad y envío de mensajes
  ----------------------------------------------------------------
  log_msg := '>>> Iniciando revisión de criticidad...'; RETURN NEXT;
  FOR r IN
    SELECT
      ac.uuid_consolidadoid,
      ac.umbralid,
      ac.fechainicio,
      ac.ultimoenvio,
      ac.ultimamedicion,
      ac.ultimoescalamiento,
      ac.nivelnotificado,
      ac.nivelescalamiento,
      c.frecuencia,
      c.escalamiento,
      c.escalon,
      u.minimo,
      u.maximo,
      me.metrica,
      no.nodo,
      f.fundo,
      ub.ubicacion,
      loc.referencia,
      loc.latitud,
      loc.longitud,
      cr.criticidad
    FROM joysense.alertaconsolidado ac
    JOIN joysense.umbral u
      ON u.umbralid = ac.umbralid
    JOIN joysense.criticidad c
      ON c.criticidadid = u.criticidadid
    JOIN joysense.localizacion loc
      ON loc.localizacionid = u.localizacionid
     AND loc.statusid = 1
    JOIN joysense.nodo no
      ON no.nodoid = loc.nodoid
    JOIN joysense.ubicacion ub
      ON ub.ubicacionid = loc.ubicacionid
    JOIN joysense.fundo f
      ON f.fundoid = ub.fundoid
    JOIN joysense.metrica me
      ON me.metricaid = loc.metricaid
    WHERE ac.statusid = 1
  LOOP
    log_msg := format(
      '--- Procesando consolidado %s (umbral %s)...',
      r.uuid_consolidadoid, r.umbralid
    ); RETURN NEXT;
    v_frecuencia      := r.frecuencia;
    v_escalamiento    := r.escalamiento;
    v_ultimo          := r.ultimoenvio;
    v_criticidad      := r.criticidad;
    v_nivelnotificado := r.nivelnotificado;
    log_msg := format(
      'Valores: frecuencia=%s | escalamiento=%s | ultimoenvio=%s | criticidad=%s | nivelnotificado=%s',
      v_frecuencia, v_escalamiento, v_ultimo, v_criticidad, v_nivelnotificado
    ); RETURN NEXT;
    --------------------------------------------------------------
    -- 2.a Envío normal por frecuencia (nivel máximo)
    --------------------------------------------------------------
    IF (v_ultimo IS NULL)
       OR (v_ultimo IS NOT NULL AND v_now - v_ultimo >= (v_frecuencia || ' hour')::interval) THEN
      log_msg := format(
        '→ Condición de frecuencia cumplida para consolidado %s',
        r.uuid_consolidadoid
      ); RETURN NEXT;
      UPDATE joysense.alertaconsolidado
      SET ultimoenvio    = v_now,
          usermodifiedid = 1,
          datemodified   = now()
      WHERE uuid_consolidadoid = r.uuid_consolidadoid;
      SELECT MAX(p.nivel)
        INTO v_nivel_max
      FROM joysense.perfilumbral pu
      JOIN joysense.perfil p
        ON p.perfilid = pu.perfilid
       AND p.statusid = 1
      WHERE pu.umbralid = r.umbralid
        AND pu.statusid = 1;
      log_msg := format(
        'Nivel máximo encontrado para umbral %s = %s',
        r.umbralid, v_nivel_max
      ); RETURN NEXT;
      INSERT INTO joysense.mensaje (
        uuid_origen,
        contactoid,
        tipo_origen,
        mensaje,
        fecha,
        statusid,
        usercreatedid,
        datecreated
      )
      SELECT
        r.uuid_consolidadoid,
        c.contactoid,
        'ALERTA_FRECUENCIA',
        LEFT(
          format(
            'Alerta %s [%s-%s], %s en %s con %s=%s, %s - %s (%s) [%s, %s]',
            r.criticidad,
            r.minimo, r.maximo,
            r.nodo,
            r.ubicacion,
            r.metrica, r.ultimamedicion,
            r.fundo,
            r.ubicacion,
            COALESCE(r.referencia, ''),
            COALESCE(r.latitud::text, ''),
            COALESCE(r.longitud::text, '')
          ),
          v_max_length
        ),
        v_now,
        1,
        1,
        now()
      FROM joysense.perfilumbral pu
      JOIN joysense.usuarioperfil up
        ON up.perfilid = pu.perfilid
       AND up.statusid = 1
      JOIN joysense.usuario us
        ON us.usuarioid = up.usuarioid
      JOIN joysense.perfil p
        ON p.perfilid = up.perfilid
      JOIN joysense.contacto c
        ON c.usuarioid = us.usuarioid
       AND c.statusid = 1
      WHERE pu.umbralid = r.umbralid
        AND pu.statusid = 1
        AND p.nivel = v_nivel_max;
      UPDATE joysense.alertaconsolidado
      SET nivelnotificado = v_nivel_max
      WHERE uuid_consolidadoid = r.uuid_consolidadoid;
    END IF;
    --------------------------------------------------------------
    -- 3) Escalamiento (simplificado)
    --------------------------------------------------------------
    IF (r.ultimoescalamiento IS NULL AND v_now - r.fechainicio >= (v_escalamiento || ' hour')::interval)
       OR (r.ultimoescalamiento IS NOT NULL AND v_now - r.ultimoescalamiento >= (v_escalamiento || ' hour')::interval) THEN
      log_msg := format(
        '→ Condición de escalamiento cumplida para consolidado %s',
        r.uuid_consolidadoid
      ); RETURN NEXT;
      UPDATE joysense.alertaconsolidado
      SET ultimoescalamiento = v_now,
          usermodifiedid     = 1,
          datemodified       = now()
      WHERE uuid_consolidadoid = r.uuid_consolidadoid;
      v_nivel_base := COALESCE(r.nivelescalamiento, r.nivelnotificado);
      IF v_nivel_base IS NULL THEN
        CONTINUE;
      END IF;
      INSERT INTO joysense.mensaje (
        uuid_origen,
        contactoid,
        tipo_origen,
        mensaje,
        fecha,
        statusid,
        usercreatedid,
        datecreated
      )
      SELECT
        r.uuid_consolidadoid,
        c.contactoid,
        'ALERTA_ESCALAMIENTO',
        LEFT(
          format(
            'Escalamiento alerta %s [%s-%s], %s en %s con %s=%s, %s - %s (%s) [%s, %s] %s',
            r.criticidad,
            r.minimo, r.maximo,
            r.nodo,
            r.ubicacion,
            r.metrica, r.ultimamedicion,
            r.fundo,
            r.ubicacion,
            COALESCE(r.referencia, ''),
            COALESCE(r.latitud::text, ''),
            COALESCE(r.longitud::text, ''),
            p.perfil
          ),
          v_max_length
        ),
        v_now,
        1,
        1,
        now()
      FROM joysense.perfilumbral pu
      JOIN joysense.perfil p
        ON p.perfilid = pu.perfilid
      JOIN joysense.usuarioperfil up
        ON up.perfilid = pu.perfilid
       AND up.statusid = 1
      JOIN joysense.usuario us
        ON us.usuarioid = up.usuarioid
      JOIN joysense.contacto c
        ON c.usuarioid = us.usuarioid
       AND c.statusid = 1
      WHERE pu.umbralid = r.umbralid
        AND pu.statusid = 1
        AND p.nivel <= v_nivel_base
        AND p.nivel >= GREATEST(v_nivel_base - r.escalon + 1, 0);
      UPDATE joysense.alertaconsolidado
      SET nivelescalamiento = GREATEST(v_nivel_base - r.escalon, 0)
      WHERE uuid_consolidadoid = r.uuid_consolidadoid;
    END IF;
  END LOOP;
  log_msg := '--- FIN fn_consolidar_alertas ---'; RETURN NEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_get_table_metadata(tbl_name text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth'
AS $function$
DECLARE
  result json;
BEGIN
  SELECT json_build_object(
    'columns', COALESCE(
      (SELECT json_agg(
        json_build_object(
          'column_name', column_name,
          'data_type', data_type,
          'is_nullable', is_nullable,
          'column_default', column_default
        )
      )
      FROM information_schema.columns
      WHERE table_schema = 'joysense'
        AND table_name   = tbl_name),
      '[]'::json
    ),
    'info', COALESCE(
      (SELECT json_build_object(
        'table_name', table_name,
        'table_type', table_type
      )
      FROM information_schema.tables
      WHERE table_schema = 'joysense'
        AND table_name   = tbl_name),
      json_build_object(
        'table_name', tbl_name,
        'table_type', 'BASE TABLE'
      )
    ),
    'constraints', COALESCE(
      (SELECT json_agg(
        json_build_object(
          'constraint_name', constraint_name,
          'constraint_type', constraint_type
        )
      )
      FROM information_schema.table_constraints
      WHERE table_schema = 'joysense'
        AND table_name   = tbl_name),
      '[]'::json
    )
  ) INTO result;
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_insertar_medicion()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth'
AS $function$
DECLARE
    v_localizacionid integer;
BEGIN
    -- 1) Resolver la localización asociada al id_device
    SELECT a.localizacionid
      INTO v_localizacionid
    FROM joysense.asociacion a
    WHERE a.id_device = NEW.id_device
      AND a.statusid = 1
    ORDER BY a.datecreated DESC
    LIMIT 1;
    IF v_localizacionid IS NULL THEN
        INSERT INTO joysense.sensor_valor_error (
            id_device,
            error,
            valor,
            fecha,
            statusid
        )
        VALUES (
            NEW.id_device,
            format('No se encontró asociación activa para id_device=%s en joysense.asociacion', NEW.id_device),
            NEW.valor,
            NEW.fecha,
            NEW.statusid
        );
        RETURN NEW;
    END IF;
    -- 2) Insertar en medicion
    BEGIN
        INSERT INTO joysense.medicion (
            localizacionid,
            fecha,
            medicion,
            usercreatedid
        ) VALUES (
            v_localizacionid,
            NEW.fecha,
            NEW.valor,
            1
        );
    EXCEPTION WHEN OTHERS THEN
        INSERT INTO joysense.sensor_valor_error (
            id_device,
            error,
            valor,
            fecha,
            statusid
        )
        VALUES (
            NEW.id_device,
            format('Error al insertar en medicion: %s', SQLERRM),
            NEW.valor,
            NEW.fecha,
            NEW.statusid
        );
        RETURN NEW;
    END;
    -- 3) Eliminar el registro procesado de staging
    DELETE FROM joysense.sensor_valor 
    WHERE id_device = NEW.id_device 
    AND fecha = NEW.fecha;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_medicion_dispara_alerta()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth'
AS $function$
BEGIN
  /*
    NEW: medicionid, localizacionid, fecha, medicion, usercreatedid
  */
  WITH umbrales_fuera AS (
    SELECT u.umbralid, u.minimo, u.maximo, u.umbral
    FROM joysense.umbral u
    WHERE u.statusid       = 1
      AND u.localizacionid = NEW.localizacionid
      AND (NEW.medicion < u.minimo OR NEW.medicion > u.maximo)
  )
  INSERT INTO joysense.alerta (umbralid, medicionid, fecha, usercreatedid)
  SELECT
    uf.umbralid,
    NEW.medicionid,
    NEW.fecha,
    COALESCE(NEW.usercreatedid, 1)
  FROM umbrales_fuera uf;
  RETURN NULL; -- AFTER trigger
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_reset_password(p_login text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'extensions', 'auth'
AS $function$
DECLARE
    v_usuarioid     INTEGER;
    v_email         TEXT;
    v_new_password  TEXT;
    v_hashed_password TEXT;
    v_api_key       TEXT;
BEGIN
    -- Buscar usuario
    SELECT usuarioid
      INTO v_usuarioid
    FROM joysense.usuario
    WHERE login = p_login
      AND statusid = 1;
    IF v_usuarioid IS NULL THEN
        RAISE EXCEPTION 'No existe un usuario activo con el login: %', p_login;
    END IF;
    -- Buscar correo
    SELECT correo
      INTO v_email
    FROM joysense.correo
    WHERE usuarioid = v_usuarioid
      AND statusid = 1
    ORDER BY correoid DESC
    LIMIT 1;
    IF v_email IS NULL THEN
        RAISE EXCEPTION 'El usuario % no tiene un correo activo registrado.', p_login;
    END IF;
    -- Generar nueva contraseña
    v_new_password := substring(encode(extensions.gen_random_bytes(8), 'base64') FROM 1 FOR 10);
    v_hashed_password := crypt(v_new_password, gen_salt('bf'));
    UPDATE joysense.usuario
    SET password_hash  = v_hashed_password,
        datemodified   = now(),
        usermodifiedid = 1
    WHERE usuarioid = v_usuarioid;
    -- Leer API Key desde Vault
    SELECT decrypted_secret
      INTO v_api_key
    FROM vault.decrypted_secrets
    WHERE name = 'RESEND_API_KEY';
    IF v_api_key IS NULL THEN
        RAISE EXCEPTION 'El Secret RESEND_API_KEY no está definido en Supabase.';
    END IF;
    -- Enviar correo
    PERFORM net.http_post(
        url := 'https://api.resend.com/emails',
        headers := jsonb_build_object(
            'Authorization', format('Bearer %s', v_api_key),
            'Content-Type', 'application/json'
        ),
        body := jsonb_build_object(
            'from', 'Soporte JoySense <no-reply@updates.agricolaandrea.com>',
            'to', v_email,
            'subject', 'Recuperación de contraseña',
            'text', format('Hola %s, tu nueva contraseña temporal es: %s', p_login, v_new_password)
        )
    );
    RETURN format('Se ha enviado una nueva contraseña al correo %s', v_email);
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_validar_umbral_minimo_maximo()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth'
AS $function$
BEGIN
    IF NEW.minimo >= NEW.maximo THEN
        RAISE EXCEPTION 'El valor mínimo (%s) debe ser menor que el valor máximo (%s)',
            NEW.minimo, NEW.maximo;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE VIEW joysense.v_perfiles_geografia_final AS SELECT DISTINCT u.useruuid,
    pgp.perfilid,
    pa.paisid,
    em.empresaid,
    fu.fundoid,
    ub.ubicacionid,
    pgp.puede_ver,
    pgp.puede_insertar,
    pgp.puede_actualizar
   FROM ((((((joysense.usuarioperfil pu
     JOIN joysense.usuario u ON ((u.usuarioid = pu.usuarioid)))
     JOIN joysense.perfil_geografia_permiso pgp ON (((pgp.perfilid = pu.perfilid) AND (pgp.statusid = 1))))
     LEFT JOIN joysense.pais pa ON ((pgp.paisid = pa.paisid)))
     LEFT JOIN joysense.empresa em ON ((pgp.empresaid = em.empresaid)))
     LEFT JOIN joysense.fundo fu ON ((pgp.fundoid = fu.fundoid)))
     LEFT JOIN joysense.ubicacion ub ON ((pgp.ubicacionid = ub.ubicacionid)))
  WHERE (pu.statusid = 1);

CREATE OR REPLACE VIEW joysense.v_permiso_empresa AS SELECT DISTINCT useruuid,
    empresaid,
    puede_ver,
    puede_insertar,
    puede_actualizar
   FROM joysense.v_perfiles_geografia_final
  WHERE (empresaid IS NOT NULL);

CREATE OR REPLACE VIEW joysense.v_permiso_fundo AS SELECT DISTINCT useruuid,
    fundoid,
    puede_ver,
    puede_insertar,
    puede_actualizar
   FROM joysense.v_perfiles_geografia_final
  WHERE (fundoid IS NOT NULL);

CREATE OR REPLACE VIEW joysense.v_permiso_localizacion AS SELECT DISTINCT l.localizacionid,
    pgf.useruuid,
    pgf.puede_ver,
    pgf.puede_insertar,
    pgf.puede_actualizar
   FROM ((((((joysense.localizacion l
     JOIN joysense.nodo n ON ((n.nodoid = l.nodoid)))
     JOIN joysense.ubicacion ub ON ((ub.ubicacionid = n.ubicacionid)))
     JOIN joysense.fundo fu ON ((fu.fundoid = ub.fundoid)))
     JOIN joysense.empresa em ON ((em.empresaid = fu.empresaid)))
     JOIN joysense.pais pa ON ((pa.paisid = em.paisid)))
     JOIN joysense.v_perfiles_geografia_final pgf ON (((pgf.paisid = pa.paisid) OR (pgf.empresaid = em.empresaid) OR (pgf.fundoid = fu.fundoid) OR (pgf.ubicacionid = ub.ubicacionid))));

CREATE OR REPLACE VIEW joysense.v_permiso_nodo AS SELECT DISTINCT n.nodoid,
    pgf.useruuid,
    pgf.puede_ver,
    pgf.puede_insertar,
    pgf.puede_actualizar
   FROM (((((joysense.nodo n
     JOIN joysense.ubicacion ub ON ((ub.ubicacionid = n.ubicacionid)))
     JOIN joysense.fundo fu ON ((fu.fundoid = ub.fundoid)))
     JOIN joysense.empresa em ON ((em.empresaid = fu.empresaid)))
     JOIN joysense.pais pa ON ((pa.paisid = em.paisid)))
     JOIN joysense.v_perfiles_geografia_final pgf ON (((pgf.paisid = pa.paisid) OR (pgf.empresaid = em.empresaid) OR (pgf.fundoid = fu.fundoid) OR (pgf.ubicacionid = ub.ubicacionid))));

CREATE OR REPLACE VIEW joysense.v_permiso_pais AS SELECT DISTINCT useruuid,
    paisid,
    puede_ver,
    puede_insertar,
    puede_actualizar
   FROM joysense.v_perfiles_geografia_final
  WHERE (paisid IS NOT NULL);

CREATE OR REPLACE VIEW joysense.v_permiso_ubicacion AS SELECT DISTINCT useruuid,
    ubicacionid,
    puede_ver,
    puede_insertar,
    puede_actualizar
   FROM joysense.v_perfiles_geografia_final
  WHERE (ubicacionid IS NOT NULL);

CREATE TRIGGER trg_auditar_umbral AFTER INSERT OR UPDATE ON joysense.umbral FOR EACH ROW EXECUTE FUNCTION joysense.fn_auditar_umbral();

CREATE TRIGGER trg_insertar_medicion AFTER INSERT ON joysense.sensor_valor FOR EACH ROW EXECUTE FUNCTION joysense.fn_insertar_medicion();

CREATE TRIGGER trg_medicion_dispara_alerta AFTER INSERT ON joysense.medicion FOR EACH ROW EXECUTE FUNCTION joysense.fn_medicion_dispara_alerta();

CREATE TRIGGER trg_sync_usuario_con_auth AFTER INSERT ON joysense.usuario FOR EACH ROW EXECUTE FUNCTION joysense.fn_sync_usuario_con_auth();

CREATE TRIGGER trg_validar_umbral BEFORE INSERT OR UPDATE ON joysense.umbral FOR EACH ROW EXECUTE FUNCTION joysense.fn_validar_umbral_minimo_maximo();

CREATE TRIGGER wh_enviar_whatsapp AFTER INSERT ON joysense.mensaje FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://fagswxnjkcavchfrnrhs.supabase.co/functions/v1/enviar-mensaje', 'POST', '{"Content-type":"application/json","Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhZ3N3eG5qa2NhdmNoZnJucmhzIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NzE1NDMyNywiZXhwIjoyMDYyNzMwMzI3fQ.ioeluR-iTWJ7-w_7UAuMl_aPXHJM6nlhv6Nh4hohBjw"}', '{}', '5000');

CREATE OR REPLACE FUNCTION joysense.fn_sync_usuario_auth(p_usuarioid integer)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth', 'extensions'
AS $function$
DECLARE
  v_usuario   joysense.usuario%ROWTYPE;
  v_email     text;
  v_user_id   uuid;
  v_now       timestamptz := now();
BEGIN
  ------------------------------------------------------------------
  -- 1) Obtener datos del usuario
  ------------------------------------------------------------------
  SELECT *
    INTO v_usuario
  FROM joysense.usuario
  WHERE usuarioid = p_usuarioid;
  IF NOT FOUND THEN
     RAISE EXCEPTION 'Usuario % no existe en joysense.usuario', p_usuarioid;
  END IF;
  ------------------------------------------------------------------
  -- 2) Si ya tiene useruuid, no volvemos a crear nada
  ------------------------------------------------------------------
  IF v_usuario.useruuid IS NOT NULL THEN
     RETURN v_usuario.useruuid;
  END IF;
  ------------------------------------------------------------------
  -- 3) Obtener correo activo (igual que en fn_reset_password)
  ------------------------------------------------------------------
  SELECT c.correo
    INTO v_email
  FROM joysense.correo c
  WHERE c.usuarioid = p_usuarioid
    AND c.statusid  = 1
  ORDER BY c.correoid DESC
  LIMIT 1;
  IF v_email IS NULL THEN
     RAISE EXCEPTION
       'Usuario % no tiene correo activo, no se puede crear auth.user',
       p_usuarioid;
  END IF;
  ------------------------------------------------------------------
  -- 4) Generar UUID (id) para auth.users
  ------------------------------------------------------------------
  v_user_id := extensions.gen_random_uuid();
  ------------------------------------------------------------------
  -- 5) Insertar en auth.users
  --    - encrypted_password: reutilizamos joysense.usuario.password_hash
  --    - aud / role: 'authenticated'
  --    - instance_id: valor estándar '0000...0000'
  --    - meta: guardamos login / nombre / apellido como raw_user_meta_data
  ------------------------------------------------------------------
  INSERT INTO auth.users (
     id,
     instance_id,
     email,
     encrypted_password,
     email_confirmed_at,
     created_at,
     updated_at,
     last_sign_in_at,
     aud,
     "role",
     raw_app_meta_data,
     raw_user_meta_data
  )
  VALUES (
     v_user_id,
     '00000000-0000-0000-0000-000000000000',
     v_email,
     v_usuario.password_hash,
     v_now,
     v_now,
     v_now,
     v_now,
     'authenticated',
     'authenticated',
     jsonb_build_object('provider','email','providers', array['email']),
     jsonb_build_object(
        'login',      v_usuario.login,
        'firstname',  v_usuario.firstname,
        'lastname',   v_usuario.lastname
     )
  );
  ------------------------------------------------------------------
  -- 6) Insertar en auth.identities
  --    (estructura mínima: id, user_id, identity_data, provider, fechas)
  ------------------------------------------------------------------
  INSERT INTO auth.identities (
     id,
     user_id,
     identity_data,
     provider,
     last_sign_in_at,
     created_at,
     updated_at
  )
  VALUES (
     extensions.gen_random_uuid(),
     v_user_id,
     jsonb_build_object(
       'sub',   v_user_id::text,
       'email', v_email
     ),
     'email',
     v_now,
     v_now,
     v_now
  );
  ------------------------------------------------------------------
  -- 7) Guardar el UUID en joysense.usuario.useruuid
  ------------------------------------------------------------------
  UPDATE joysense.usuario
  SET useruuid     = v_user_id,
      datemodified = v_now
  WHERE usuarioid  = p_usuarioid;
  RETURN v_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION joysense.fn_sync_usuario_con_auth()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'joysense', 'public', 'auth', 'extensions'
AS $function$
DECLARE
    v_user_id uuid;
    v_now timestamptz := now();
BEGIN
    ------------------------------------------------------------------
    -- 1. Validar que NEW.login sea un correo válido mínimamente
    ------------------------------------------------------------------
    IF NEW.login NOT LIKE '%@%' THEN
        RAISE EXCEPTION 'El login debe ser un correo válido (NEW.login = %)', NEW.login;
    END IF;
    ------------------------------------------------------------------
    -- 2. Crear correo principal en joysense.correo (statusid = 1)
    --    Solo si NO existe ya
    ------------------------------------------------------------------
    INSERT INTO joysense.correo(usuarioid, correo, statusid, usercreatedid)
    VALUES (NEW.usuarioid, NEW.login, 1, NEW.usercreatedid)
    ON CONFLICT DO NOTHING;
    ------------------------------------------------------------------
    -- 3. Crear usuario en Supabase Auth
    ------------------------------------------------------------------
    v_user_id := extensions.gen_random_uuid();
    INSERT INTO auth.users(
        id,
        instance_id,
        email,
        encrypted_password,
        email_confirmed_at,
        created_at,
        updated_at,
        last_sign_in_at,
        aud,
        role,
        raw_app_meta_data,
        raw_user_meta_data
    )
    VALUES(
        v_user_id,
        '00000000-0000-0000-0000-000000000000',
        NEW.login,
        NEW.password_hash,   -- ya viene hasheado en tu BD
        v_now,
        v_now,
        v_now,
        v_now,
        'authenticated',
        'authenticated',
        jsonb_build_object('provider','email','providers', array['email']),
        jsonb_build_object(
            'login', NEW.login,
            'firstname', NEW.firstname,
            'lastname',  NEW.lastname
        )
    );
    ------------------------------------------------------------------
    -- 4. Insertar identidad
    ------------------------------------------------------------------
    INSERT INTO auth.identities(
        id,
        user_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
    )
    VALUES(
        extensions.gen_random_uuid(),
        v_user_id,
        jsonb_build_object('sub', v_user_id::text, 'email', NEW.login),
        'email',
        v_now,
        v_now,
        v_now
    );
    ------------------------------------------------------------------
    -- 5. Actualizar joysense.usuario con el UUID
    ------------------------------------------------------------------
    UPDATE joysense.usuario
    SET useruuid = v_user_id,
        datemodified = v_now
    WHERE usuarioid = NEW.usuarioid;
    RETURN NEW;
END;
$function$
;

